/**
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * If it is not possible or desirable to put the notice in a particular
 * file, then You may include the notice in a location (such as a LICENSE
 * file in a relevant directory) where a recipient would be likely to look
 * for such a notice.

 * 
 */
 
/*  ---------------------------------------------------------------------------
 *  U.S. Government, Department of the Army
 *  Army Materiel Command
 *  Research Development Engineering Command
 *  Communications Electronics Research Development and Engineering Center
 *  ---------------------------------------------------------------------------
 */

package org.miloss.fgsms.osagent.callbacks;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.InputStream;
import java.util.GregorianCalendar;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.ws.RequestWrapper;
import javax.xml.ws.ResponseWrapper;
import org.miloss.fgsms.common.Constants;
import org.miloss.fgsms.services.interfaces.agentcallbackservice.AccessDeniedException;
import org.miloss.fgsms.services.interfaces.agentcallbackservice.RemoteAgentCallbackPort;
import org.miloss.fgsms.services.interfaces.agentcallbackservice.ServiceUnavailableException;
import org.miloss.fgsms.services.interfaces.common.GetOperatingStatusRequestMessage;
import org.miloss.fgsms.services.interfaces.common.GetOperatingStatusResponseMessage;
import org.miloss.fgsms.osagent.OSAgent;
import org.apache.log4j.Level;
import org.miloss.fgsms.common.Logger;;

/**
 * Remote Agent Callback Port Type. This provides callback from the fgsms
 * instance
 *
 * This class was generated by the JAX-WS RI. JAX-WS RI 2.1.7-04/11/2011 03:11
 * PM(mockbuild)- Generated source version: 2.1
 *
 * @author AO
 * @since 6.3
 */
@Deprecated

@WebService(name = "remoteAgentCallbackPort", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService")
@XmlSeeAlso({
    org.miloss.fgsms.services.interfaces.faults.ObjectFactory.class,
    org.miloss.fgsms.services.interfaces.agentcallbackservice.ObjectFactory.class,
    us.gov.ic.ism.v2.ObjectFactory.class,
    org.miloss.fgsms.services.interfaces.common.ObjectFactory.class
})
public class RemoteAgentCallbackImpl implements RemoteAgentCallbackPort, Runnable {

    public RemoteAgentCallbackImpl(OSAgent ref) {
        if (ref == null) {
            throw new IllegalArgumentException();
        }
        INTERNAL_REFERENCE = ref;

    }
    protected boolean acceptingcommands = true;
    private OSAgent INTERNAL_REFERENCE = null;

    /**
     * Executes a set of tasks via command line
     *
     *
     * @param id
     * @param waitforexit
     * @param authorizationcode
     * @param command
     * @param workingDir
     * @return returns boolean
     * @throws ServiceUnavailableException
     * @throws AccessDeniedException
     */
    @WebMethod(operationName = "ExecuteTasks", action = "urn:org:miloss:fgsms:services:interfaces:remoteAgentCallbackService/ExecuteTasks")
    @WebResult(name = "Accepted", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService")
    @RequestWrapper(localName = "ExecuteTasks", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService", className = "org.miloss.fgsms.services.interfaces.agentcallbackservice.ExecuteTasks")
    @ResponseWrapper(localName = "ExecuteTasksResponse", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService", className = "org.miloss.fgsms.services.interfaces.agentcallbackservice.ExecuteTasksResponse")
    public boolean executeTasks(
            @WebParam(name = "authorizationcode", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService") String authorizationcode,
            @WebParam(name = "id", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService") String id,
            @WebParam(name = "working_dir", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService") String workingDir,
            @WebParam(name = "command", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService") String command,
            @WebParam(name = "waitforexit", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService") boolean waitforexit)
            throws AccessDeniedException, ServiceUnavailableException {
        if (acceptingcommands) {
            //enqueue the task
            AdminCommand c = new AdminCommand(this);
            c.authcode = authorizationcode;
            c.id = id;
            c.enqueuedat = System.currentTimeMillis();
            c.workingdir = workingDir;
            c.command = command;
            c.waitfor = waitforexit;
            the_queue.add(c);
            if (currentthread < maxthreads) {
                Thread t = new Thread(this);
                t.start();
            }
            return true;
        } else {
            return false;
        }
    }

    @Override
    public void run() {
        currentthread++;
        while (!the_queue.isEmpty()) {
            Object j = the_queue.remove();
            if (j instanceof AdminCommand) {
                AdminCommand command = (AdminCommand) j;
                try {
                    authorizeCommand(command);
                    Runtime run = Runtime.getRuntime();
                    Process pr = null;
                    log.log(Level.INFO, "starting command " + command.id + " " + command.command);
                    pr = run.exec(command.command, null, new File(command.workingdir));

                    if (command.waitfor) {
                        command.exitcode = pr.waitFor();
                        log.log(Level.INFO, "completed command " + command.id + " exit code " + command.exitcode);
                        InputStream os = pr.getInputStream();
                        InputStream err = pr.getErrorStream();
                        BufferedInputStream bos = new BufferedInputStream(os);
                        byte[] buffer = new byte[1024];
                        int k = -1;
                        k = bos.read(buffer);
                        while (k > 0 && k < 1024) {
                            command.result_stdout += new String(buffer, 0, k,Constants.CHARSET);
                            k = bos.read(buffer);
                        }
                        bos.close();
                        os.close();

                        bos = new BufferedInputStream(err);
                        k = bos.read(buffer);
                        while (k > 0 && bos.read(buffer) < 1024) {
                            command.result_stderr += new String(buffer, 0, k);
                            k = bos.read(buffer);
                        }
                        bos.close();
                        err.close();


                        pr.destroy();
                    }
                } catch (Exception ex) {
                    log.log(Level.WARN, "error running job " + command.id, ex);
                    command.exitcode = 1000;
                    command.result_stderr = ex.getMessage();
                }
                TaskDone(command);
            }
        }
        currentthread--;
    }

    private void authorizeCommand(AdminCommand command) {
        //TODO find out how to authorize this command. prove it came from fgsms.
    }
    int maxthreads = 10;
    int currentthread = 0;
    private Queue<Object> the_queue = new ConcurrentLinkedQueue<Object>();

    private void TaskDone(AdminCommand command) {
        //call fgsms service to notify that the task is done, success or fail, send output
        log.log(Level.INFO, "task done " + command.id + " status " + command.exitcode);
    }
    static Logger log = Logger.getLogger("fgsms.fgsmsOSAgent.Callbacks");

    /**
     *
     * Gets the operating status of an remove agent
     *
     *
     * @param request
     * @return returns
     * org.miloss.fgsms.services.interfaces.agentcallbackservice.GetOperatingStatusResponseMessage
     * @throws ServiceUnavailableException
     * @throws AccessDeniedException
     */
    @WebMethod(operationName = "GetOperatingStatus", action = "urn:org:miloss:fgsms:services:interfaces:remoteAgentCallbackService/GetOperatingStatus")
    @WebResult(name = "response", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService")
    @RequestWrapper(localName = "GetOperatingStatus", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService", className = "org.miloss.fgsms.services.interfaces.agentcallbackservice.GetOperatingStatus")
    @ResponseWrapper(localName = "GetOperatingStatusResponse", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService", className = "org.miloss.fgsms.services.interfaces.agentcallbackservice.GetOperatingStatusResponse")
    public GetOperatingStatusResponseMessage getOperatingStatus(
            @WebParam(name = "request", targetNamespace = "urn:org:miloss:fgsms:services:interfaces:agentCallbackService") GetOperatingStatusRequestMessage request)
            throws AccessDeniedException, ServiceUnavailableException {
        if (request == null || request.getClassification() == null || request.getClassification().getClassification() == null) {
            throw new IllegalArgumentException("Must specify a classification level");
        }
        if (INTERNAL_REFERENCE == null) {
            throw new IllegalStateException("Agent reference is null");
        }
        GetOperatingStatusResponseMessage res = new GetOperatingStatusResponseMessage();

        GregorianCalendar gcal = new GregorianCalendar();
        gcal.setTimeInMillis(INTERNAL_REFERENCE.startedat);
        try {
            res.setStartedAt((gcal));
        } catch (Exception ex) {
        }
        res.setClassification(INTERNAL_REFERENCE.getClassLevelAsCopy());

        res.setDataSentSuccessfully(new Long(INTERNAL_REFERENCE.datasend_success));

        res.setDataNotSentSuccessfully(new Long(INTERNAL_REFERENCE.datasend_failures));

        res.setVersionInfo(new GetOperatingStatusResponseMessage.VersionInfo());
        res.getVersionInfo().setVersionData(org.miloss.fgsms.common.Constants.Version);
        res.getVersionInfo().setVersionSource(org.miloss.fgsms.common.Constants.class.getCanonicalName());

        res.setStatus(acceptingcommands);
        return res;
    }
}
